#!/usr/bin/env python3
'''
Date : 1402/01/04
Author : AmirhosseinKhanshabani - @AmirZoyber
 
Not all Windows API calls are documented on MSDN.
the documented APIs we used so far operate in user mode.
when calling a user mode API, we eventually end up in kernel mode.
windows APIs are an abstraction layer over the native API.
These native API calls we are interested in, are defind in NTDLL.
NTDLL is the native API for Windows NT.
'''
# search for virtualaloc msdn in google

from ctypes import *
from ctypes import wintypes

kernel = windll.kernel32
SIZE_T = c_size_t

virtualAlloc = kernel.VirtualAlloc
virtualAlloc.argtypes = [wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD]
virtualAlloc.restype = wintypes.LPVOID # pointer to void

MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x40

ptr = virtualAlloc(None , 1024*4, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)

error = GetLastError()

if error != 0:
    print("Error code: {0}".format(error))
    print(WinError(error))
print("VirtualAlloc returned: {0}".format(hex(ptr)))
# output :
# VirtualAlloc returned: 0x26730150000

'''search for NtAllocateVirtualMemory msdn in google'''
# we use it for allocating memory in kernel mode
nt = windll.ntdll
NTSTATUS = wintypes.DWORD
NtAllocateVirtualMemory = nt.NtAllocateVirtualMemory
NtAllocateVirtualMemory.argtypes = [wintypes.HANDLE, POINTER(wintypes.LPVOID), wintypes.ULONG, POINTER(SIZE_T), wintypes.ULONG, wintypes.ULONG]
NtAllocateVirtualMemory.restype = NTSTATUS

handle = 0xffffffffffffffff
address = wintypes.LPVOID(0x0)
zero = wintypes.ULONG(0)
size = wintypes.ULONG(1024*12)

ptr2 = NtAllocateVirtualMemory(handle, byref(address), zero, byref(size), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)

if ptr2 != 0:
    print("Error code: {0}".format(ptr2))
    print(WinError(ptr2))
print("NtAllocateVirtualMemory returned: {0}".format(hex(address.value)))
# output :
# NtAllocateVirtualMemory returned: 0x26730150000
'''
you can check this on graphical mode with program <Process Hacker>.
'''